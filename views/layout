<!doctype html>
<html>
  <head>
    <title>Get In It</title>
    <script src="http://ajax.googleapis.com/ajax/libs/dojo/1.7.1/dojo/dojo.js"
      data-dojo-config="async: true"></script>
    <script>
      require(["dojo/_base/xhr", "dojo/on", "dojo/dom",
        "dojo/topic", "dojo/domReady!"],
        function(xhr, on, dom, topic) {

          // Submit handler
          on(dom.byId("workout-form"), "submit", function(evt) {
            var messageNode = dom.byId("message");

            evt.preventDefault();

            // Let's try the Deferred version
            // Hmmm.  Looks like the ioArgs object is not avail when you use the Deferred method.
            // Also, I really don't see the benefit of using deferreds, but of course I'm
            // still new at this.
            var def= xhr.post({
              url: "/p",
              timeout: 5000,
              form: this,
            });

            def.then(function(response) {
                console.log("success! ", response)
                // handler should reset the form
                // need to investigate how to do that

                // book says that error handler should always return the response.  why?
                // - return a response if you plan on adding more callbacks to the deferred object
                // - from reading the "promises" article on Sitepen, the new Deferred object returns
                // a copy of the original return value, called a "promises".  This "promise" is
                // read-only and is unaffected and available to every callback in the chain.  Therefore,
                // there is no need to expicitly return the response.
                //return response;
                topic.publish("submitted");
              },
              function(error) {
                messageNode.innerHTML = "Ajax request failed!";
                console.log("post request failed");
                console.log(error);
                // book says that error handler should always return the response.  why?
                //return response;
              }
            );
            //)
            // how would I go about adding a new callback to the orig xhr that is only fired after
            // the successful callback returns? if possible, i can use this mechanism to request
            // the resulting workout log collection
            // wow! it worked.  what happens if the post request fails?
            // looks like it still executes to get request even though the post request fails.
            // can I inspect the status of the post request before issuing the get?
            // 
            // I wonder if the request for logs should be implemented via pub/sub?  the deferred
            // chaining seems overly complicated for this purpose, since the request for
            // logs does not depend on the return value of the post to the db.
            /*.then(function() {
              xhr.get({
                url: "/logs",
                handleAs: "json"
              })
              .then(function(jsonData) {
                  console.log("request for logs succeeded", jsonData);
                },
                function(error) {
                  messageNode.innerHTML = "logs request failed!";
                  console.log("get request failed");
                }
              );
            });*/
          });
          // Pub/Sub version
          // this works! :)
          topic.subscribe("submitted", function() {
            xhr.get({
              url: "/logs",
              handleAs: "json"
            })
            .then(function(jsonData) {
                console.log("request for logs succeeded", jsonData);
              },
              function(error) {
                messageNode.innerHTML = "logs request failed!";
                console.log("get request failed");
              }
            );
          });
        });
    </script>
    <!-- sinatra looks in the public directory for css and image files -->
    <link href="css/bootstrap.css" rel="stylesheet" />
  </head>
  <body>
    <div class="container">
      <div class="row">
        <div class="span12">
          <h1>Get It In</h1>
          <div><%= yield %></div>
          <div id="message"></div>
        </div>
      </div>
    </div>
  </body>
</html>
